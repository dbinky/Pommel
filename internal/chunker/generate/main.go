//go:build ignore

// This program generates treesitter_generated.go by reading all language
// configuration files from the languages/ directory.
//
// Usage: go run internal/chunker/generate/main.go
package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

// grammarToImport maps grammar names (from YAML configs) to their Go import paths.
// This is the one hardcoded piece - it defines what tree-sitter grammars are available.
var grammarToImport = map[string]importInfo{
	"bash":       {pkg: "bash", path: "github.com/smacker/go-tree-sitter/bash"},
	"c":          {pkg: "c", path: "github.com/smacker/go-tree-sitter/c"},
	"cpp":        {pkg: "cpp", path: "github.com/smacker/go-tree-sitter/cpp"},
	"csharp":     {pkg: "csharp", path: "github.com/smacker/go-tree-sitter/csharp"},
	"c_sharp":    {pkg: "csharp", path: "github.com/smacker/go-tree-sitter/csharp"}, // alias
	"css":        {pkg: "css", path: "github.com/smacker/go-tree-sitter/css"},
	"cue":        {pkg: "cue", path: "github.com/smacker/go-tree-sitter/cue"},
	"dockerfile": {pkg: "dockerfile", path: "github.com/smacker/go-tree-sitter/dockerfile"},
	"elixir":     {pkg: "elixir", path: "github.com/smacker/go-tree-sitter/elixir"},
	"elm":        {pkg: "elm", path: "github.com/smacker/go-tree-sitter/elm"},
	"go":         {pkg: "golang", path: "github.com/smacker/go-tree-sitter/golang"},
	"groovy":     {pkg: "groovy", path: "github.com/smacker/go-tree-sitter/groovy"},
	"hcl":        {pkg: "hcl", path: "github.com/smacker/go-tree-sitter/hcl"},
	"html":       {pkg: "html", path: "github.com/smacker/go-tree-sitter/html"},
	"java":       {pkg: "java", path: "github.com/smacker/go-tree-sitter/java"},
	"javascript": {pkg: "javascript", path: "github.com/smacker/go-tree-sitter/javascript"},
	"jsx":        {pkg: "javascript", path: "github.com/smacker/go-tree-sitter/javascript"}, // JSX uses JavaScript parser
	"kotlin":     {pkg: "kotlin", path: "github.com/smacker/go-tree-sitter/kotlin"},
	"lua":        {pkg: "lua", path: "github.com/smacker/go-tree-sitter/lua"},
	"markdown":   {pkg: "markdown", path: "github.com/smacker/go-tree-sitter/markdown", special: true}, // Custom parsing in treesitter.go
	"ocaml":      {pkg: "ocaml", path: "github.com/smacker/go-tree-sitter/ocaml"},
	"php":        {pkg: "php", path: "github.com/smacker/go-tree-sitter/php"},
	"protobuf":   {pkg: "protobuf", path: "github.com/smacker/go-tree-sitter/protobuf"},
	"python":     {pkg: "python", path: "github.com/smacker/go-tree-sitter/python"},
	"ruby":       {pkg: "ruby", path: "github.com/smacker/go-tree-sitter/ruby"},
	"rust":       {pkg: "rust", path: "github.com/smacker/go-tree-sitter/rust"},
	"scala":      {pkg: "scala", path: "github.com/smacker/go-tree-sitter/scala"},
	"sql":        {pkg: "sql", path: "github.com/smacker/go-tree-sitter/sql"},
	"svelte":     {pkg: "svelte", path: "github.com/smacker/go-tree-sitter/svelte"},
	"swift":      {pkg: "swift", path: "github.com/smacker/go-tree-sitter/swift"},
	"toml":       {pkg: "toml", path: "github.com/smacker/go-tree-sitter/toml"},
	"typescript": {pkg: "typescript", path: "github.com/smacker/go-tree-sitter/typescript/typescript"},
	"tsx":        {pkg: "tsx", path: "github.com/smacker/go-tree-sitter/typescript/tsx"},
	"yaml":       {pkg: "yaml", path: "github.com/smacker/go-tree-sitter/yaml"},
}

type importInfo struct {
	pkg     string // Package alias for import
	path    string // Full import path
	special bool   // If true, skip grammarRegistry (has custom parsing in treesitter.go)
}

// LanguageConfig represents a language YAML configuration file
type LanguageConfig struct {
	Language    string   `yaml:"language"`
	DisplayName string   `yaml:"display_name"`
	Extensions  []string `yaml:"extensions"`
	TreeSitter  struct {
		Grammar string `yaml:"grammar"`
	} `yaml:"tree_sitter"`
}

// TemplateData holds data for the generated file template
type TemplateData struct {
	Imports            []ImportEntry
	GrammarEntries     []GrammarEntry
	ExtensionEntries   []ExtensionEntry
	LanguageNames      []string
	LanguageToGrammars []LanguageGrammarEntry
}

type LanguageGrammarEntry struct {
	Language string
	Grammar  string
}

type ImportEntry struct {
	Alias string
	Path  string
}

type GrammarEntry struct {
	Name    string
	PkgFunc string
}

type ExtensionEntry struct {
	Ext  string
	Lang string
}

const outputTemplate = `// Code generated by go run internal/chunker/generate/main.go; DO NOT EDIT.

package chunker

import (
	sitter "github.com/smacker/go-tree-sitter"
{{- range .Imports}}
	{{.Alias}} "{{.Path}}"
{{- end}}
)

// grammarRegistry maps grammar names (from config) to tree-sitter language getters.
var grammarRegistry = map[string]func() *sitter.Language{
{{- range .GrammarEntries}}
	"{{.Name}}": {{.PkgFunc}}.GetLanguage,
{{- end}}
}

// extensionToLanguage maps file extensions to language names.
var extensionToLanguage = map[string]string{
{{- range .ExtensionEntries}}
	"{{.Ext}}": "{{.Lang}}",
{{- end}}
}

// supportedLanguages is the list of all supported language names.
var supportedLanguages = []string{
{{- range .LanguageNames}}
	"{{.}}",
{{- end}}
}

// DetectLanguageByExtension returns the language name for a given filename.
// Returns "unknown" if the extension is not recognized.
func DetectLanguageByExtension(filename string) string {
	ext := filepath.Ext(filename)
	// Enforce case-sensitivity: only lowercase extensions match
	if ext != strings.ToLower(ext) {
		return "unknown"
	}
	if lang, ok := extensionToLanguage[ext]; ok {
		return lang
	}
	return "unknown"
}

// GetLanguageGrammar returns the tree-sitter language for the given grammar name.
func GetLanguageGrammar(name string) (*sitter.Language, error) {
	getter, ok := grammarRegistry[name]
	if !ok {
		return nil, fmt.Errorf("unsupported grammar: %s", name)
	}
	return getter(), nil
}

// IsGrammarSupported returns true if the given grammar name is supported.
func IsGrammarSupported(name string) bool {
	_, ok := grammarRegistry[name]
	return ok
}

// SupportedLanguages returns a list of all supported language names.
func SupportedLanguages() []string {
	return supportedLanguages
}
`

func main() {
	// Find project root (where languages/ directory is)
	projectRoot, err := findProjectRoot()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error finding project root: %v\n", err)
		os.Exit(1)
	}

	languagesDir := filepath.Join(projectRoot, "languages")
	outputPath := filepath.Join(projectRoot, "internal", "chunker", "treesitter_generated.go")

	// Read all YAML files
	configs, err := readLanguageConfigs(languagesDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading language configs: %v\n", err)
		os.Exit(1)
	}

	if len(configs) == 0 {
		fmt.Fprintf(os.Stderr, "No language configuration files found in %s\n", languagesDir)
		os.Exit(1)
	}

	// Validate configs
	if err := validateConfigs(configs); err != nil {
		fmt.Fprintf(os.Stderr, "Validation error: %v\n", err)
		os.Exit(1)
	}

	// Generate template data
	data := buildTemplateData(configs)

	// Generate output
	output, err := generateOutput(data)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error generating output: %v\n", err)
		os.Exit(1)
	}

	// Write output file
	if err := os.WriteFile(outputPath, output, 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing output file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %s with %d languages\n", outputPath, len(configs))
}

func findProjectRoot() (string, error) {
	// Start from current directory and look for go.mod
	dir, err := os.Getwd()
	if err != nil {
		return "", err
	}

	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}

		parent := filepath.Dir(dir)
		if parent == dir {
			return "", fmt.Errorf("could not find project root (go.mod)")
		}
		dir = parent
	}
}

func readLanguageConfigs(dir string) ([]LanguageConfig, error) {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return nil, fmt.Errorf("reading directory: %w", err)
	}

	var configs []LanguageConfig
	for _, entry := range entries {
		if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".yaml") {
			continue
		}

		path := filepath.Join(dir, entry.Name())
		data, err := os.ReadFile(path)
		if err != nil {
			return nil, fmt.Errorf("reading %s: %w", entry.Name(), err)
		}

		var cfg LanguageConfig
		if err := yaml.Unmarshal(data, &cfg); err != nil {
			return nil, fmt.Errorf("parsing %s: %w", entry.Name(), err)
		}

		configs = append(configs, cfg)
	}

	return configs, nil
}

func validateConfigs(configs []LanguageConfig) error {
	seenLanguages := make(map[string]bool)
	seenExtensions := make(map[string]string)

	for _, cfg := range configs {
		// Check required fields
		if cfg.Language == "" {
			return fmt.Errorf("config missing 'language' field")
		}
		if cfg.TreeSitter.Grammar == "" {
			return fmt.Errorf("config for %s missing 'tree_sitter.grammar' field", cfg.Language)
		}
		if len(cfg.Extensions) == 0 {
			return fmt.Errorf("config for %s has no extensions", cfg.Language)
		}

		// Check grammar is known
		if _, ok := grammarToImport[cfg.TreeSitter.Grammar]; !ok {
			return fmt.Errorf("config for %s references unknown grammar '%s'", cfg.Language, cfg.TreeSitter.Grammar)
		}

		// Check for duplicate languages
		if seenLanguages[cfg.Language] {
			return fmt.Errorf("duplicate language: %s", cfg.Language)
		}
		seenLanguages[cfg.Language] = true

		// Check for duplicate extensions
		for _, ext := range cfg.Extensions {
			if existing, ok := seenExtensions[ext]; ok {
				return fmt.Errorf("duplicate extension '%s' in %s (already used by %s)", ext, cfg.Language, existing)
			}
			seenExtensions[ext] = cfg.Language
		}
	}

	return nil
}

func buildTemplateData(configs []LanguageConfig) TemplateData {
	// Collect unique imports (skip special grammars with custom parsing)
	importSet := make(map[string]importInfo)
	for _, cfg := range configs {
		info := grammarToImport[cfg.TreeSitter.Grammar]
		if info.special {
			continue // Skip special grammars - they have custom parsing in treesitter.go
		}
		importSet[info.path] = info
	}

	// Sort imports by path
	var imports []ImportEntry
	var paths []string
	for path := range importSet {
		paths = append(paths, path)
	}
	sort.Strings(paths)
	for _, path := range paths {
		info := importSet[path]
		imports = append(imports, ImportEntry{Alias: info.pkg, Path: path})
	}

	// Build grammar entries (skip special grammars with custom parsing)
	var grammarEntries []GrammarEntry
	for _, cfg := range configs {
		info := grammarToImport[cfg.TreeSitter.Grammar]
		if info.special {
			continue // Skip special grammars - they have custom parsing in treesitter.go
		}
		grammarEntries = append(grammarEntries, GrammarEntry{
			Name:    cfg.TreeSitter.Grammar,
			PkgFunc: info.pkg,
		})
	}
	// Sort and deduplicate grammar entries
	sort.Slice(grammarEntries, func(i, j int) bool {
		return grammarEntries[i].Name < grammarEntries[j].Name
	})
	grammarEntries = dedupeGrammarEntries(grammarEntries)

	// Build extension entries (map to user-friendly language names)
	var extensionEntries []ExtensionEntry
	for _, cfg := range configs {
		for _, ext := range cfg.Extensions {
			extensionEntries = append(extensionEntries, ExtensionEntry{
				Ext:  ext,
				Lang: cfg.Language, // Use user-friendly language name
			})
		}
	}
	sort.Slice(extensionEntries, func(i, j int) bool {
		return extensionEntries[i].Ext < extensionEntries[j].Ext
	})

	// Collect user-friendly language names
	var languageNames []string
	for _, cfg := range configs {
		languageNames = append(languageNames, cfg.Language)
	}
	sort.Strings(languageNames)
	languageNames = dedupeStrings(languageNames)

	// Build language to grammar mapping
	var languageToGrammars []LanguageGrammarEntry
	for _, cfg := range configs {
		languageToGrammars = append(languageToGrammars, LanguageGrammarEntry{
			Language: cfg.Language,
			Grammar:  cfg.TreeSitter.Grammar,
		})
	}
	sort.Slice(languageToGrammars, func(i, j int) bool {
		return languageToGrammars[i].Language < languageToGrammars[j].Language
	})

	return TemplateData{
		Imports:            imports,
		GrammarEntries:     grammarEntries,
		ExtensionEntries:   extensionEntries,
		LanguageNames:      languageNames,
		LanguageToGrammars: languageToGrammars,
	}
}

func dedupeGrammarEntries(entries []GrammarEntry) []GrammarEntry {
	seen := make(map[string]bool)
	var result []GrammarEntry
	for _, e := range entries {
		if !seen[e.Name] {
			seen[e.Name] = true
			result = append(result, e)
		}
	}
	return result
}

func dedupeStrings(items []string) []string {
	seen := make(map[string]bool)
	var result []string
	for _, item := range items {
		if !seen[item] {
			seen[item] = true
			result = append(result, item)
		}
	}
	return result
}

func generateOutput(data TemplateData) ([]byte, error) {
	// Add required imports to the template
	tmplWithImports := `// Code generated by go run internal/chunker/generate/main.go; DO NOT EDIT.

package chunker

import (
	"fmt"
	"path/filepath"
	"strings"

	sitter "github.com/smacker/go-tree-sitter"
{{- range .Imports}}
	{{.Alias}} "{{.Path}}"
{{- end}}
)

// grammarRegistry maps grammar names (from config) to tree-sitter language getters.
var grammarRegistry = map[string]func() *sitter.Language{
{{- range .GrammarEntries}}
	"{{.Name}}": {{.PkgFunc}}.GetLanguage,
{{- end}}
}

// languageToGrammar maps user-friendly language names to grammar names.
var languageToGrammar = map[string]string{
{{- range .LanguageToGrammars}}
	"{{.Language}}": "{{.Grammar}}",
{{- end}}
}

// extensionToLanguage maps file extensions to user-friendly language names.
var extensionToLanguage = map[string]string{
{{- range .ExtensionEntries}}
	"{{.Ext}}": "{{.Lang}}",
{{- end}}
}

// supportedLanguages is the list of all supported language names.
var supportedLanguages = []string{
{{- range .LanguageNames}}
	"{{.}}",
{{- end}}
}

// DetectLanguageByExtension returns the language name for a given filename.
// Returns "unknown" if the extension is not recognized.
func DetectLanguageByExtension(filename string) string {
	ext := filepath.Ext(filename)
	// Enforce case-sensitivity: only lowercase extensions match
	if ext != strings.ToLower(ext) {
		return "unknown"
	}
	if lang, ok := extensionToLanguage[ext]; ok {
		return lang
	}
	return "unknown"
}

// GetGrammarForLanguage returns the grammar name for the given language name.
// Returns the language name itself if not found (for backwards compatibility).
func GetGrammarForLanguage(lang string) string {
	if grammar, ok := languageToGrammar[lang]; ok {
		return grammar
	}
	return lang
}

// GetLanguageGrammar returns the tree-sitter language for the given grammar name.
func GetLanguageGrammar(name string) (*sitter.Language, error) {
	getter, ok := grammarRegistry[name]
	if !ok {
		return nil, fmt.Errorf("unsupported grammar: %s", name)
	}
	return getter(), nil
}

// IsLanguageSupported returns true if the given language name is supported.
func IsLanguageSupported(lang string) bool {
	_, ok := languageToGrammar[lang]
	return ok
}

// IsGrammarSupported returns true if the given grammar name is supported.
func IsGrammarSupported(name string) bool {
	_, ok := grammarRegistry[name]
	return ok
}

// SupportedLanguages returns a list of all supported language names.
func SupportedLanguages() []string {
	return supportedLanguages
}
`

	tmpl, err := template.New("output").Parse(tmplWithImports)
	if err != nil {
		return nil, fmt.Errorf("parsing template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("executing template: %w", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Return unformatted if formatting fails (helps debug)
		return buf.Bytes(), fmt.Errorf("formatting output (returning unformatted): %w", err)
	}

	return formatted, nil
}
